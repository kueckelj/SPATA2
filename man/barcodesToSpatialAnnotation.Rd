% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/b.R
\name{barcodesToSpatialAnnotation}
\alias{barcodesToSpatialAnnotation}
\title{Create spatial annotations from a list of barcodes}
\usage{
barcodesToSpatialAnnotation(
  object,
  barcodes,
  id,
  tags = NULL,
  tags_expand = TRUE,
  use_dbscan = TRUE,
  inner_borders = TRUE,
  eps = getCCD(object) * 1.25,
  minPts = 3,
  min_size = nBarcodes(object) * 0.005,
  fct_incr = 20,
  force1 = FALSE,
  concavity = 2,
  overwrite = FALSE,
  class = "SpatialAnnotation",
  verbose = NULL,
  ...
)
}
\arguments{
\item{object}{An object of class \code{\link{SPATA2}} or, in case of S4 generics,
objects of classes for which a method has been defined.}

\item{barcodes}{Character vector. A vector of data points that cover histological
areas that are supposed to annotated as spatial annotations.}

\item{id}{Character value. The ID of the spatial annotation. If \code{NULL},
the ID of the annotation is created by combining the string \emph{'spat_ann'} with
the index the new annotation has in the list of all annotations.}

\item{tags}{A character vector of tags for the spatial annotation.}

\item{tags_expand}{Logical value. If \code{TRUE}, the tags with which the image
annotations are tagged are expanded by the unsuffixed \code{id}, the \code{variable},
the \code{threshold} and \emph{'barcodesToSpatialAnnotation()'}.}

\item{use_dbscan}{Logical value. If \code{TRUE}, the DBSCAN algorithm is used to identify
spatial clusters and outliers before the outline of the spatial annotation is drawn.}

\item{inner_borders}{Logical value. If \code{TRUE}, the algorithm checks whether the
annotation requires inner borders and sets them accordingly. If \code{FALSE}, only
an outer border is created.}

\item{eps}{Distance measure. Given to \code{eps} of \code{\link[dbscan:dbscan]{dbscan::dbscan()}}. Determines
the size (radius) of the epsilon neighborhood.}

\item{minPts}{Numeric value. Given to \code{\link[dbscan:dbscan]{dbscan::dbscan()}}. Determines the
number of minimum points required in the eps neighborhood for core points
(including the point itself)}

\item{min_size}{Numeric value. The minimum number of data points a dbscan cluster
must have in order not to be discarded as a spatial outlier.}

\item{force1}{Logical value. If \code{TRUE}, spatial sub groups identified by DBSCAN
are merged into one cluster.}

\item{concavity}{Numeric value. Given to argument \code{concavity} of
\code{\link[concaveman:concaveman]{concaveman::concaveman()}}. Determines the relative measure of concavity.
1 results in a relatively detailed shape, Infinity results in a convex hull.
You can use values lower than 1, but they can produce pretty crazy shapes.}

\item{overwrite}{Logical value. Must be \code{TRUE} to allow overwriting.}

\item{verbose}{Logical. If set to TRUE informative messages regarding
the computational progress will be printed.

(Warning messages will always be printed.)}

\item{...}{Additional slot content given to \code{methods::new()} when
constructing the \code{\link{SpatialAnnotation}} object.}
}
\value{
The input object containing the added or computed
results.
}
\description{
Creates spatial annotations from a list of barcodes from
data points that cover the area to be outlined. See details for more information.
}
\details{
The functions filters the coordinates data.frame obtained via \code{getCoordsDf()}
based on the input of argument \code{barcodes}.

Following filtering, if \code{use_dbscan} is \code{TRUE}, the DBSCAN algorithm
identifies spatial outliers, which are then removed. Furthermore, if DBSCAN
detects multiple dense clusters, they can be merged into a single group
if \code{force1} is also set to \code{TRUE}.

It is essential to note that bypassing the DBSCAN step may lead to the inclusion
of individual data points dispersed across the sample. This results in an image
annotation that essentially spans the entirety of the sample, lacking the
segregation of specific variable expressions. Similarly, enabling \code{force1}
might unify multiple segregated areas, present on both sides of the sample, into one
group and subsequently, one spatial annotation encompassing the whole sample.
Consider to allow the creation of multiple spatial annotations (suffixed with an index)
and merging them afterwards via \code{mergeSpatialAnnotations()} if they are too
close together.

Lastly, the remaining data points are fed into the concaveman algorithm on a
per-group basis. The algorithm calculates concave polygons outlining the groups
of data points. If \code{dbscan_use} is \code{FALSE}, all data points that remained after the
initial filtering are submitted to the algorithm. Subsequently, these polygons are
integrated into \code{addSpatialAnnotation()} along with the unsuffixed \code{id} and
\code{tags} input arguments. The ID is suffixed with an index for each group.
}
\section{Distance measures}{


The vignette on distance measures in SPATA2 has been replaced. Click
\code{\link[=concept_distance_measure]{here}} to read it.
}

\examples{

library(SPATA2)
data(spatial_segmentations)

object <- downloadSpataObject("313_T")

# add 'histology' variable
object <-
 addFeatures(
  object = object,
  feature_df = spatial_segmentations[["313_T"]]
   )

plotImageGgplot(object) + plotSurface(object, color_by = "histology", pt_alpha = 0.5)

# obtain list of barcodes that cover necrotic areas
necrotic_barcodes <-
 getFeatureDf(object) \%>\%
 dplyr::filter(histology == "necrosis") \%>\%
 dplyr::pull("barcodes")

print(necrotic_barcodes)

# convert list of barcodes to spatial annotations with default setting
object_ex1 <-
 barcodesToSpatialAnnotation(
  object = object,
  barcodes = necrotic_barcodes,
  id = "necrosis",
  )

plotSpatialAnnotations(object_ex1, expand = "1mm")

# skip algorithm to detect multiple areas
object_ex2 <-
 barcodesToSpatialAnnotation(
  object = object,
  barcodes = necrotic_barcodes,
  id = "necrosis",
  force1 = TRUE
  )

plotSpatialAnnotations(object_ex2, expand = "1mm")

# manipulate the outline via `expand_outline`
object_ex3 <-
 barcodesToSpatialAnnotation(
  object = object,
  barcodes = necrotic_barcodes,
  id = "necrosis",
  expand_outline = getCCD(object)*4.5 # *4.5 is too high, defaults to *1.25
  )

plotSpatialAnnotations(object_ex3, expand = "1mm")

}
\seealso{
See \code{\link[=mergeSpatialAnnotations]{mergeSpatialAnnotations()}} to merge spatial annotations.

See \code{\link{SpatialAnnotation}}-class for details about the S4 architecture.
}
